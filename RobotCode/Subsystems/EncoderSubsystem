// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.subsystems;

import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants;
import com.revrobotics.*;

public class EncoderSubsystem extends SubsystemBase {
  public SparkMaxRelativeEncoder motorLeftFrontEncoder;
  public SparkMaxRelativeEncoder motorLeftBackEncoder;
  public SparkMaxRelativeEncoder motorRightFrontEncoder;
  public SparkMaxRelativeEncoder motorRightBackEncoder;
  // public SparkMaxRelativeEncoder horizontalCaster;
  // public SparkMaxRelativeEncoder leftCaster;
  // public SparkMaxRelativeEncoder rightCaster;

  
  
  
  
  //IF YOU USE ENCODER, JUST DO <Motor>.getEncoder();










  //SparkMaxRelativeEncoder Rotation Initialization
  private static final double cpr = 360;
  private static final double whd = 6; 
  //public SparkMaxRelativeEncoder kHallSensor;
  /** Creates a new SparkMaxRelativeEncoder. */
  public EncoderSubsystem() {
    // motorLeftFrontEncoder = new SparkMaxRelativeEncoder(Type(1), Constants.motorLeftFrontEncoder_ID_A);
    // motorLeftBackEncoder = new SparkMaxRelativeEncoder(Type(1), Constants.motorLeftBackEncoder_ID_A);
    // motorRightFrontEncoder = new SparkMaxRelativeEncoder(Type(1), Constants.motorRightFrontEncoder_ID_A);
    // motorRightBackEncoder = new SparkMaxRelativeEncoder(Type(1), Constants.motorRightBackEncoder_ID_A);
    // horizontalCaster = new SparkMaxRelativeEncoder(Constants.horizontalCaster_ID_A, Constants.horizontalCaster_B);
    // leftCaster = new SparkMaxRelativeEncoder(Constants.leftCaster_ID_A, Constants.leftCaster_B);
    // rightCaster = new SparkMaxRelativeEncoder(Constants.rightCaster_ID_A, Constants.rightCaster_B);
    
    //distance per pulse is pi* (wheel diameter / counts per revolution)
    // motorLeftFrontEncoder.setDistancePerPulse(Math.PI*whd/cpr); 
    // motorLeftBackEncoder.setDistancePerPulse(Math.PI*whd/cpr);
    // motorRightFrontEncoder.setDistancePerPulse(Math.PI*whd/cpr);
    // motorRightBackEncoder.setDistancePerPulse(Math.PI*whd/cpr);
    // horizontalCaster.setDistancePerPulse(Math.PI*whd/cpr);
    // leftCaster.setDistancePerPulse(Math.PI*whd/cpr);
    // rightCaster.setDistancePerPulse(Math.PI*whd/cpr);
    
  }

  @Override
  public void periodic() {
    // motorLeftFrontEncoder.getDistancePerPulse();
    // motorLeftBackEncoder.getDistancePerPulse();
    // motorRightFrontEncoder.getDistancePerPulse();
    // motorRightBackEncoder.getDistancePerPulse();
    // horizontalCaster.getDistancePerPulse();
    // leftCaster.getDistancePerPulse();
    // rightCaster.getDistancePerPulse();

  }


}

