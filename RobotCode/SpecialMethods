package frc.robot;


//Welcome to Brendan's Playground
public class SpecialMethods {
    private static final double cpr = 42;
    private static final double whd = 6; 
    public static final double Tick2Inches = Math.PI*whd/cpr;
    public static final double slow = 0.1;

    //Custom Resets
    public static void UniversalReset(){
        RobotContainer.driveTrain.navX.reset();
        RobotContainer.driveTrain.setLeftMotors(0);
        RobotContainer.driveTrain.setRightMotors(0);  
        // RobotContainer.systems.IntakeSpeeds(0);        
        // RobotContainer.systems.CargoTransferSpeeds(0);    
        RobotContainer.systems.ShooterSpeeds(0);        
        RobotContainer.driveTrain.motorLeftFrontEncoder.setPosition(0);
        RobotContainer.driveTrain.motorLeftBackEncoder.setPosition(0);
        RobotContainer.driveTrain.motorRightFrontEncoder.setPosition(0);
        RobotContainer.driveTrain.motorRightBackEncoder.setPosition(0);
    }

    public static void EncoderReset(){
        RobotContainer.driveTrain.motorLeftFrontEncoder.setPosition(0);
        RobotContainer.driveTrain.motorLeftBackEncoder.setPosition(0);
        RobotContainer.driveTrain.motorRightFrontEncoder.setPosition(0);
        RobotContainer.driveTrain.motorRightBackEncoder.setPosition(0);
    }

    public static void MotorReset(){
        RobotContainer.driveTrain.setLeftMotors(0);
        RobotContainer.driveTrain.setRightMotors(0); 
        // RobotContainer.systems.IntakeSpeeds(0);        
        // RobotContainer.systems.CargoTransferSpeeds(0);    
        RobotContainer.systems.ShooterSpeeds(0);   
    }

    public static void SensorReset(){
        RobotContainer.driveTrain.navX.reset();
    }

    
    /*Coordinate Wizard (AKA Brendan's Baby) is a method that takes in 2 Coordinates and calculates the trajectory of
    the robot that it needs to take by vizualizing every possible coordinate as a Right-Angle Triangle. On a 2D cartesian
    plane, we can use trigonometry and the distance formula in order to calculate how far the robot needs to turn and how 
    far the robot needs to move.*/
    public static void CoordinateWizard(double X1, double Y1, double X2, double Y2){
        //Angle Calculations
        double calculateMoveDistanceX = (X2-X1);
        double calculateMoveDistanceY = (Y2-Y1);
        double tangentTheta = Math.atan(calculateMoveDistanceX/calculateMoveDistanceY);
        double tangentThetaDegrees = Math.toDegrees(tangentTheta);

        //Distance Calculation using Trigonometric Distance Formula
        double moveDistance = Math.sqrt(Math.pow(calculateMoveDistanceX,2) + Math.pow(calculateMoveDistanceY,2));
        double moveInTicks = moveDistance*Tick2Inches;

        //Get RobotAngle
        double robotTheta = RobotContainer.driveTrain.navX.getAngle();

        //If Coordinate is to the right of the robot
        if (robotTheta < tangentThetaDegrees){
            while (robotTheta < tangentThetaDegrees){
                robotTheta = RobotContainer.driveTrain.navX.getAngle();
                RobotContainer.driveTrain.setLeftMotors(slow);
                RobotContainer.driveTrain.setRightMotors(-slow);    
            }
        }
        //If Coordinate is to the left of the robot
        if (robotTheta > tangentThetaDegrees){
            while (robotTheta > tangentThetaDegrees){
                robotTheta = RobotContainer.driveTrain.navX.getAngle();
                RobotContainer.driveTrain.setLeftMotors(-slow);
                RobotContainer.driveTrain.setRightMotors(slow);  
            }
        }

        MotorReset(); 
        EncoderReset(); 

        //Robot goes to Coordinate
        while (-RobotContainer.driveTrain.motorLeftFrontEncoder.getPosition() < moveInTicks &&
        -RobotContainer.driveTrain.motorLeftBackEncoder.getPosition() < moveInTicks &&
        RobotContainer.driveTrain.motorRightFrontEncoder.getPosition() < moveInTicks &&
        RobotContainer.driveTrain.motorRightBackEncoder.getPosition() < moveInTicks){

            RobotContainer.driveTrain.setLeftMotors(slow);
            RobotContainer.driveTrain.setRightMotors(slow);            
        }      
    }

    //Helps correct the robot to compensate for incompetent hardware and weight imbalances
    public static void GyroCorrection(){
        double gyro =  RobotContainer.driveTrain.navX.getAngle();
        double GyroCorrectionleftStickY = -RobotContainer.driverController_1.getY();
        double GyroCorrectionrightStickX = RobotContainer.driverController_1.getX();

        //Custom deadband necessary since you can never have a perfect angle. 
        if(GyroCorrectionleftStickY < -0.05 || GyroCorrectionleftStickY > 0.05){
            SensorReset();
            while(gyro <= -5 || gyro >= 5) {
                gyro =  RobotContainer.driveTrain.navX.getAngle();
                //Adjusts Left
                if (gyro >= 5) {
                RobotContainer.driveTrain.setLeftMotors(slow);
                }
                //Adjusts Right
                if (gyro <= -5){
                RobotContainer.driveTrain.setRightMotors(slow);
                }
            }
        }
        if(GyroCorrectionrightStickX < -0.05 || GyroCorrectionrightStickX > 0.05){
            SensorReset();
            while(gyro <= -5 || gyro >= 5) {
                gyro =  RobotContainer.driveTrain.navX.getAngle();
                //Adjusts Left
                if (gyro >= 5) {
                RobotContainer.driveTrain.setLeftMotors(slow);
                }
                //Adjusts Right
                if (gyro <= -5){
                RobotContainer.driveTrain.setRightMotors(slow);
                }
            }
        }
    }

    //Method for Intake Controls
    // public static void IntakeControls(boolean inTrigger, boolean outTrigger){
    //     if(inTrigger == true){
    //         RobotContainer.systems.IntakeSpeeds(1);
    //     }
    //     if(outTrigger == true){
    //         RobotContainer.systems.IntakeSpeeds(-1);
    //     }
    //     else{
    //         RobotContainer.systems.IntakeSpeeds(0);
    //     }
    // }
    // //Method for Cargo Transfer Controls
    // public static void CargoTransferControls(boolean inButton, boolean outButton){
    //     if(inButton == true){
    //         RobotContainer.systems.CargoTransferSpeeds(1);
    //     }
    //     if(outButton == true){
    //         RobotContainer.systems.CargoTransferSpeeds(-1);
    //     }
    //     else{
    //         RobotContainer.systems.CargoTransferSpeeds(0);
    //     }
    // }
    //Method for Shooter Controls
    public static void ShooterControls(Boolean shootButton1, Boolean shootButton2){
        if(shootButton1 == true && shootButton2 == true){
            RobotContainer.systems.ShooterSpeeds(-0.1);
        }
        else{
            RobotContainer.systems.ShooterSpeeds(0);
        }
    }

    // public static void ShooterRPMCalculator(){
    //     double StartTime = System.nanoTime();

        
    // }
}
