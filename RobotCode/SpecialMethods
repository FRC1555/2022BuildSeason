package frc.robot;


public class SpecialMethods {
    private static final double cpr = 42;
    private static final double whd = 6; 
    public static final double Tick2Inches = Math.PI*whd/cpr;
    public static final double slow = 0.1;

    public static void UniversalReset(){
        RobotContainer.driveTrain.navX.reset();
        RobotContainer.driveTrain.setLeftMotors(0);
        RobotContainer.driveTrain.setRightMotors(0);  
        RobotContainer.driveTrain.motorLeftFrontEncoder.setPosition(0);
        RobotContainer.driveTrain.motorLeftBackEncoder.setPosition(0);
        RobotContainer.driveTrain.motorRightFrontEncoder.setPosition(0);
        RobotContainer.driveTrain.motorRightBackEncoder.setPosition(0);
    }

    public static void CoordinateWizard(double X1, double Y1, double X2, double Y2){
        //Angle Calculations
        double calculateMoveDistanceX = Math.abs(X2-X1);
        double calculateMoveDistanceY = Math.abs(Y2-Y1);
        double tangentTheta = Math.atan(calculateMoveDistanceX/calculateMoveDistanceY);

        //Distance Calculation using Trigonometric Distance Formula
        double moveDistance = Math.sqrt(Math.pow(calculateMoveDistanceX,2) + Math.pow(calculateMoveDistanceY,2));
        double moveInTicks = moveDistance*Tick2Inches;

        double robotTheta = RobotContainer.driveTrain.navX.getAngle();
        //Custom deadbands necessary since you can never have a perfect angle. 
        //If Coordinate is to the right of the robot
        if (robotTheta > tangentTheta){
            while (robotTheta > tangentTheta + 5 || robotTheta > tangentTheta -5){
                robotTheta = RobotContainer.driveTrain.navX.getAngle();
                RobotContainer.driveTrain.setLeftMotors(slow);
                RobotContainer.driveTrain.setRightMotors(-slow);    
            }
        }
        //If Coordinate is to the left of the robot
        if (robotTheta < tangentTheta){
            while (robotTheta < tangentTheta + 5 || robotTheta < tangentTheta -5){
                robotTheta = RobotContainer.driveTrain.navX.getAngle();
                RobotContainer.driveTrain.setLeftMotors(-slow);
                RobotContainer.driveTrain.setRightMotors(slow);  
            }
        }
        RobotContainer.driveTrain.setLeftMotors(0);
        RobotContainer.driveTrain.setRightMotors(0);  
        //Distance
        while (-RobotContainer.driveTrain.motorLeftFrontEncoder.getPosition() < moveInTicks &&
        -RobotContainer.driveTrain.motorLeftBackEncoder.getPosition() < moveInTicks &&
        RobotContainer.driveTrain.motorRightFrontEncoder.getPosition() < moveInTicks &&
        RobotContainer.driveTrain.motorRightBackEncoder.getPosition()< moveInTicks){

        RobotContainer.driveTrain.setLeftMotors(0.5);
        RobotContainer.driveTrain.setRightMotors(0.5);
        }     
    }

    public static void GyroCorrection(){
        double gyro =  - RobotContainer.driveTrain.navX.getAngle();
    
        //Custom deadband necessary since you can never have a perfect angle. 
        while(gyro <= -5 || gyro >= 5) {
            
            gyro =  RobotContainer.driveTrain.navX.getAngle();
            //Turns Right
            if (gyro <= 5) {
            RobotContainer.driveTrain.setLeftMotors(slow);
            }
            //Turns Left
             if (gyro >= -5){
            RobotContainer.driveTrain.setRightMotors(slow);
            }
        }
    }
}

